// Code generated by Prisma (prisma@1.34.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  conversation: (where?: ConversationWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  school: (where?: SchoolWhereInput) => Promise<boolean>;
  task: (where?: TaskWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userCategory: (where?: UserCategoryWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  conversation: (
    where: ConversationWhereUniqueInput
  ) => ConversationNullablePromise;
  conversations: (args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Conversation>;
  conversationsConnection: (args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ConversationConnectionPromise;
  notification: (
    where: NotificationWhereUniqueInput
  ) => NotificationNullablePromise;
  notifications: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notification>;
  notificationsConnection: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotificationConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewNullablePromise;
  reviews: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Review>;
  reviewsConnection: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewConnectionPromise;
  school: (where: SchoolWhereUniqueInput) => SchoolNullablePromise;
  schools: (args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<School>;
  schoolsConnection: (args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SchoolConnectionPromise;
  task: (where: TaskWhereUniqueInput) => TaskNullablePromise;
  tasks: (args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Task>;
  tasksConnection: (args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TaskConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userCategory: (
    where: UserCategoryWhereUniqueInput
  ) => UserCategoryNullablePromise;
  userCategories: (args?: {
    where?: UserCategoryWhereInput;
    orderBy?: UserCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserCategory>;
  userCategoriesConnection: (args?: {
    where?: UserCategoryWhereInput;
    orderBy?: UserCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserCategoryConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createConversation: (data: ConversationCreateInput) => ConversationPromise;
  updateConversation: (args: {
    data: ConversationUpdateInput;
    where: ConversationWhereUniqueInput;
  }) => ConversationPromise;
  updateManyConversations: (args: {
    data: ConversationUpdateManyMutationInput;
    where?: ConversationWhereInput;
  }) => BatchPayloadPromise;
  upsertConversation: (args: {
    where: ConversationWhereUniqueInput;
    create: ConversationCreateInput;
    update: ConversationUpdateInput;
  }) => ConversationPromise;
  deleteConversation: (
    where: ConversationWhereUniqueInput
  ) => ConversationPromise;
  deleteManyConversations: (
    where?: ConversationWhereInput
  ) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (args: {
    data: NotificationUpdateInput;
    where: NotificationWhereUniqueInput;
  }) => NotificationPromise;
  updateManyNotifications: (args: {
    data: NotificationUpdateManyMutationInput;
    where?: NotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertNotification: (args: {
    where: NotificationWhereUniqueInput;
    create: NotificationCreateInput;
    update: NotificationUpdateInput;
  }) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (args: {
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
  }) => ReviewPromise;
  updateManyReviews: (args: {
    data: ReviewUpdateManyMutationInput;
    where?: ReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertReview: (args: {
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
  }) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createSchool: (data: SchoolCreateInput) => SchoolPromise;
  updateSchool: (args: {
    data: SchoolUpdateInput;
    where: SchoolWhereUniqueInput;
  }) => SchoolPromise;
  updateManySchools: (args: {
    data: SchoolUpdateManyMutationInput;
    where?: SchoolWhereInput;
  }) => BatchPayloadPromise;
  upsertSchool: (args: {
    where: SchoolWhereUniqueInput;
    create: SchoolCreateInput;
    update: SchoolUpdateInput;
  }) => SchoolPromise;
  deleteSchool: (where: SchoolWhereUniqueInput) => SchoolPromise;
  deleteManySchools: (where?: SchoolWhereInput) => BatchPayloadPromise;
  createTask: (data: TaskCreateInput) => TaskPromise;
  updateTask: (args: {
    data: TaskUpdateInput;
    where: TaskWhereUniqueInput;
  }) => TaskPromise;
  updateManyTasks: (args: {
    data: TaskUpdateManyMutationInput;
    where?: TaskWhereInput;
  }) => BatchPayloadPromise;
  upsertTask: (args: {
    where: TaskWhereUniqueInput;
    create: TaskCreateInput;
    update: TaskUpdateInput;
  }) => TaskPromise;
  deleteTask: (where: TaskWhereUniqueInput) => TaskPromise;
  deleteManyTasks: (where?: TaskWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserCategory: (data: UserCategoryCreateInput) => UserCategoryPromise;
  updateUserCategory: (args: {
    data: UserCategoryUpdateInput;
    where: UserCategoryWhereUniqueInput;
  }) => UserCategoryPromise;
  updateManyUserCategories: (args: {
    data: UserCategoryUpdateManyMutationInput;
    where?: UserCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertUserCategory: (args: {
    where: UserCategoryWhereUniqueInput;
    create: UserCategoryCreateInput;
    update: UserCategoryUpdateInput;
  }) => UserCategoryPromise;
  deleteUserCategory: (
    where: UserCategoryWhereUniqueInput
  ) => UserCategoryPromise;
  deleteManyUserCategories: (
    where?: UserCategoryWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  conversation: (
    where?: ConversationSubscriptionWhereInput
  ) => ConversationSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  school: (
    where?: SchoolSubscriptionWhereInput
  ) => SchoolSubscriptionPayloadSubscription;
  task: (
    where?: TaskSubscriptionWhereInput
  ) => TaskSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userCategory: (
    where?: UserCategorySubscriptionWhereInput
  ) => UserCategorySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TASK_TYPE = "GROUP" | "ONE_TO_ONE";

export type TaskOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "location_ASC"
  | "location_DESC"
  | "eventTime_ASC"
  | "eventTime_DESC"
  | "featured_ASC"
  | "featured_DESC"
  | "flagged_as_objectionable_ASC"
  | "flagged_as_objectionable_DESC"
  | "created_by_joinmi_ASC"
  | "created_by_joinmi_DESC"
  | "task_type_ASC"
  | "task_type_DESC"
  | "active_ASC"
  | "active_DESC"
  | "expiration_ASC"
  | "expiration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "rating_ASC"
  | "rating_DESC";

export type SchoolOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "domain_ASC"
  | "domain_DESC"
  | "active_ASC"
  | "active_DESC";

export type RATING = "POSITIVE" | "NEGATIVE" | "NOT_RATED";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_url_ASC"
  | "image_url_DESC"
  | "data_ASC"
  | "data_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "expiration_ASC"
  | "expiration_DESC"
  | "read_ASC"
  | "read_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "token_ASC"
  | "token_DESC"
  | "name_ASC"
  | "name_DESC"
  | "username_ASC"
  | "username_DESC"
  | "description_ASC"
  | "description_DESC"
  | "major_ASC"
  | "major_DESC"
  | "townYouGrewUpIn_ASC"
  | "townYouGrewUpIn_DESC"
  | "favoriteHobby_ASC"
  | "favoriteHobby_DESC"
  | "photo_url_ASC"
  | "photo_url_DESC"
  | "cover_photo_url_ASC"
  | "cover_photo_url_DESC"
  | "flagged_as_objectionable_ASC"
  | "flagged_as_objectionable_DESC"
  | "view_objectionable_content_ASC"
  | "view_objectionable_content_DESC"
  | "school_ASC"
  | "school_DESC"
  | "about_me_ASC"
  | "about_me_DESC"
  | "receive_push_notifications_ASC"
  | "receive_push_notifications_DESC"
  | "oneSignalPlayerId_ASC"
  | "oneSignalPlayerId_DESC"
  | "fcm_token_ASC"
  | "fcm_token_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "facebook_social_link_ASC"
  | "facebook_social_link_DESC"
  | "twitter_social_link_ASC"
  | "twitter_social_link_DESC"
  | "instagram_social_link_ASC"
  | "instagram_social_link_DESC"
  | "snapchat_social_link_ASC"
  | "snapchat_social_link_DESC"
  | "role_ASC"
  | "role_DESC";

export type ROLE = "SUPER_USER" | "USER";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "image_url_ASC"
  | "image_url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type UserCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "selected_ASC"
  | "selected_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ConversationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  title?: Maybe<String>;
}>;

export interface ConversationUpdateWithoutTaskDataInput {
  description?: Maybe<String>;
  active?: Maybe<Boolean>;
  participants?: Maybe<UserUpdateManyWithoutConversationsInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  image_url?: Maybe<String>;
  image_url_not?: Maybe<String>;
  image_url_in?: Maybe<String[] | String>;
  image_url_not_in?: Maybe<String[] | String>;
  image_url_lt?: Maybe<String>;
  image_url_lte?: Maybe<String>;
  image_url_gt?: Maybe<String>;
  image_url_gte?: Maybe<String>;
  image_url_contains?: Maybe<String>;
  image_url_not_contains?: Maybe<String>;
  image_url_starts_with?: Maybe<String>;
  image_url_not_starts_with?: Maybe<String>;
  image_url_ends_with?: Maybe<String>;
  image_url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  tasks_every?: Maybe<TaskWhereInput>;
  tasks_some?: Maybe<TaskWhereInput>;
  tasks_none?: Maybe<TaskWhereInput>;
  userCategories_every?: Maybe<UserCategoryWhereInput>;
  userCategories_some?: Maybe<UserCategoryWhereInput>;
  userCategories_none?: Maybe<UserCategoryWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface UserUpdateManyWithoutConversationsInput {
  create?: Maybe<
    UserCreateWithoutConversationsInput[] | UserCreateWithoutConversationsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutConversationsInput[]
    | UserUpdateWithWhereUniqueWithoutConversationsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutConversationsInput[]
    | UserUpsertWithWhereUniqueWithoutConversationsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  category?: Maybe<CategoryWhereInput>;
  selected?: Maybe<Boolean>;
  selected_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<UserCategoryWhereInput[] | UserCategoryWhereInput>;
  OR?: Maybe<UserCategoryWhereInput[] | UserCategoryWhereInput>;
  NOT?: Maybe<UserCategoryWhereInput[] | UserCategoryWhereInput>;
}

export interface UserCreateWithoutCategoriesInput {
  id?: Maybe<ID_Input>;
  email: String;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  block_list?: Maybe<UserCreateManyInput>;
  tasks?: Maybe<TaskCreateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewCreateManyWithoutReviewerInput>;
  conversations?: Maybe<ConversationCreateManyWithoutParticipantsInput>;
}

export interface TaskUpdateManyWithWhereNestedInput {
  where: TaskScalarWhereInput;
  data: TaskUpdateManyDataInput;
}

export interface CategoryUpdateInput {
  title?: Maybe<String>;
  image_url?: Maybe<String>;
  tasks?: Maybe<TaskUpdateManyWithoutCategoryInput>;
  userCategories?: Maybe<UserCategoryUpdateManyWithoutCategoryInput>;
}

export interface UserUpdateWithWhereUniqueWithoutConversationsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutConversationsDataInput;
}

export interface TaskUpdateManyWithoutCategoryInput {
  create?: Maybe<
    TaskCreateWithoutCategoryInput[] | TaskCreateWithoutCategoryInput
  >;
  delete?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
  connect?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
  set?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
  disconnect?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
  update?: Maybe<
    | TaskUpdateWithWhereUniqueWithoutCategoryInput[]
    | TaskUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | TaskUpsertWithWhereUniqueWithoutCategoryInput[]
    | TaskUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<TaskScalarWhereInput[] | TaskScalarWhereInput>;
  updateMany?: Maybe<
    TaskUpdateManyWithWhereNestedInput[] | TaskUpdateManyWithWhereNestedInput
  >;
}

export interface UserCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserCategoryWhereInput>;
  AND?: Maybe<
    UserCategorySubscriptionWhereInput[] | UserCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    UserCategorySubscriptionWhereInput[] | UserCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserCategorySubscriptionWhereInput[] | UserCategorySubscriptionWhereInput
  >;
}

export interface TaskUpdateWithWhereUniqueWithoutCategoryInput {
  where: TaskWhereUniqueInput;
  data: TaskUpdateWithoutCategoryDataInput;
}

export interface NotificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  image_url?: Maybe<String>;
  image_url_not?: Maybe<String>;
  image_url_in?: Maybe<String[] | String>;
  image_url_not_in?: Maybe<String[] | String>;
  image_url_lt?: Maybe<String>;
  image_url_lte?: Maybe<String>;
  image_url_gt?: Maybe<String>;
  image_url_gte?: Maybe<String>;
  image_url_contains?: Maybe<String>;
  image_url_not_contains?: Maybe<String>;
  image_url_starts_with?: Maybe<String>;
  image_url_not_starts_with?: Maybe<String>;
  image_url_ends_with?: Maybe<String>;
  image_url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  read?: Maybe<Boolean>;
  read_not?: Maybe<Boolean>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  OR?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  NOT?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
}

export interface TaskUpdateWithoutCategoryDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  participants?: Maybe<UserUpdateManyWithoutTasksInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutTaskInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutTaskInput>;
}

export interface TaskSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TaskWhereInput>;
  AND?: Maybe<TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput>;
  OR?: Maybe<TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput>;
  NOT?: Maybe<TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReviewWhereInput>;
  AND?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  OR?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  NOT?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  block_list?: Maybe<UserUpdateManyInput>;
  tasks?: Maybe<TaskUpdateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryUpdateManyWithoutUserInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutParticipantsInput>;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NotificationWhereInput>;
  AND?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
}

export interface NotificationUpdateManyWithoutUserInput {
  create?: Maybe<
    NotificationCreateWithoutUserInput[] | NotificationCreateWithoutUserInput
  >;
  delete?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  set?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  disconnect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  update?: Maybe<
    | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    | NotificationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    | NotificationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    NotificationScalarWhereInput[] | NotificationScalarWhereInput
  >;
  updateMany?: Maybe<
    | NotificationUpdateManyWithWhereNestedInput[]
    | NotificationUpdateManyWithWhereNestedInput
  >;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutUserDataInput;
}

export interface UserCategoryUpdateInput {
  category?: Maybe<CategoryUpdateOneWithoutUserCategoriesInput>;
  selected?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneWithoutCategoriesInput>;
}

export interface NotificationUpdateWithoutUserDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image_url?: Maybe<String>;
  data?: Maybe<Json>;
  expiration?: Maybe<DateTimeInput>;
  read?: Maybe<Boolean>;
}

export type ConversationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutUserDataInput;
  create: NotificationCreateWithoutUserInput;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  block_list?: Maybe<UserUpdateManyInput>;
  tasks?: Maybe<TaskUpdateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryUpdateManyWithoutUserInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutParticipantsInput>;
}

export interface NotificationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  image_url?: Maybe<String>;
  image_url_not?: Maybe<String>;
  image_url_in?: Maybe<String[] | String>;
  image_url_not_in?: Maybe<String[] | String>;
  image_url_lt?: Maybe<String>;
  image_url_lte?: Maybe<String>;
  image_url_gt?: Maybe<String>;
  image_url_gte?: Maybe<String>;
  image_url_contains?: Maybe<String>;
  image_url_not_contains?: Maybe<String>;
  image_url_starts_with?: Maybe<String>;
  image_url_not_starts_with?: Maybe<String>;
  image_url_ends_with?: Maybe<String>;
  image_url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  read?: Maybe<Boolean>;
  read_not?: Maybe<Boolean>;
  AND?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  OR?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  NOT?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput;
  data: NotificationUpdateManyDataInput;
}

export interface TaskCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator: UserCreateOneInput;
  participants?: Maybe<UserCreateManyWithoutTasksInput>;
  conversations?: Maybe<ConversationCreateManyWithoutTaskInput>;
  reviews?: Maybe<ReviewCreateManyWithoutTaskInput>;
  category: CategoryCreateOneWithoutTasksInput;
}

export interface NotificationUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image_url?: Maybe<String>;
  data?: Maybe<Json>;
  expiration?: Maybe<DateTimeInput>;
  read?: Maybe<Boolean>;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface SchoolCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  domain: String;
  active?: Maybe<Boolean>;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export type SchoolWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SchoolWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  domain?: Maybe<String>;
  domain_not?: Maybe<String>;
  domain_in?: Maybe<String[] | String>;
  domain_not_in?: Maybe<String[] | String>;
  domain_lt?: Maybe<String>;
  domain_lte?: Maybe<String>;
  domain_gt?: Maybe<String>;
  domain_gte?: Maybe<String>;
  domain_contains?: Maybe<String>;
  domain_not_contains?: Maybe<String>;
  domain_starts_with?: Maybe<String>;
  domain_not_starts_with?: Maybe<String>;
  domain_ends_with?: Maybe<String>;
  domain_not_ends_with?: Maybe<String>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  AND?: Maybe<SchoolWhereInput[] | SchoolWhereInput>;
  OR?: Maybe<SchoolWhereInput[] | SchoolWhereInput>;
  NOT?: Maybe<SchoolWhereInput[] | SchoolWhereInput>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  major?: Maybe<String>;
  major_not?: Maybe<String>;
  major_in?: Maybe<String[] | String>;
  major_not_in?: Maybe<String[] | String>;
  major_lt?: Maybe<String>;
  major_lte?: Maybe<String>;
  major_gt?: Maybe<String>;
  major_gte?: Maybe<String>;
  major_contains?: Maybe<String>;
  major_not_contains?: Maybe<String>;
  major_starts_with?: Maybe<String>;
  major_not_starts_with?: Maybe<String>;
  major_ends_with?: Maybe<String>;
  major_not_ends_with?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  townYouGrewUpIn_not?: Maybe<String>;
  townYouGrewUpIn_in?: Maybe<String[] | String>;
  townYouGrewUpIn_not_in?: Maybe<String[] | String>;
  townYouGrewUpIn_lt?: Maybe<String>;
  townYouGrewUpIn_lte?: Maybe<String>;
  townYouGrewUpIn_gt?: Maybe<String>;
  townYouGrewUpIn_gte?: Maybe<String>;
  townYouGrewUpIn_contains?: Maybe<String>;
  townYouGrewUpIn_not_contains?: Maybe<String>;
  townYouGrewUpIn_starts_with?: Maybe<String>;
  townYouGrewUpIn_not_starts_with?: Maybe<String>;
  townYouGrewUpIn_ends_with?: Maybe<String>;
  townYouGrewUpIn_not_ends_with?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  favoriteHobby_not?: Maybe<String>;
  favoriteHobby_in?: Maybe<String[] | String>;
  favoriteHobby_not_in?: Maybe<String[] | String>;
  favoriteHobby_lt?: Maybe<String>;
  favoriteHobby_lte?: Maybe<String>;
  favoriteHobby_gt?: Maybe<String>;
  favoriteHobby_gte?: Maybe<String>;
  favoriteHobby_contains?: Maybe<String>;
  favoriteHobby_not_contains?: Maybe<String>;
  favoriteHobby_starts_with?: Maybe<String>;
  favoriteHobby_not_starts_with?: Maybe<String>;
  favoriteHobby_ends_with?: Maybe<String>;
  favoriteHobby_not_ends_with?: Maybe<String>;
  photo_url?: Maybe<String>;
  photo_url_not?: Maybe<String>;
  photo_url_in?: Maybe<String[] | String>;
  photo_url_not_in?: Maybe<String[] | String>;
  photo_url_lt?: Maybe<String>;
  photo_url_lte?: Maybe<String>;
  photo_url_gt?: Maybe<String>;
  photo_url_gte?: Maybe<String>;
  photo_url_contains?: Maybe<String>;
  photo_url_not_contains?: Maybe<String>;
  photo_url_starts_with?: Maybe<String>;
  photo_url_not_starts_with?: Maybe<String>;
  photo_url_ends_with?: Maybe<String>;
  photo_url_not_ends_with?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  cover_photo_url_not?: Maybe<String>;
  cover_photo_url_in?: Maybe<String[] | String>;
  cover_photo_url_not_in?: Maybe<String[] | String>;
  cover_photo_url_lt?: Maybe<String>;
  cover_photo_url_lte?: Maybe<String>;
  cover_photo_url_gt?: Maybe<String>;
  cover_photo_url_gte?: Maybe<String>;
  cover_photo_url_contains?: Maybe<String>;
  cover_photo_url_not_contains?: Maybe<String>;
  cover_photo_url_starts_with?: Maybe<String>;
  cover_photo_url_not_starts_with?: Maybe<String>;
  cover_photo_url_ends_with?: Maybe<String>;
  cover_photo_url_not_ends_with?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  flagged_as_objectionable_not?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  view_objectionable_content_not?: Maybe<Boolean>;
  school?: Maybe<String>;
  school_not?: Maybe<String>;
  school_in?: Maybe<String[] | String>;
  school_not_in?: Maybe<String[] | String>;
  school_lt?: Maybe<String>;
  school_lte?: Maybe<String>;
  school_gt?: Maybe<String>;
  school_gte?: Maybe<String>;
  school_contains?: Maybe<String>;
  school_not_contains?: Maybe<String>;
  school_starts_with?: Maybe<String>;
  school_not_starts_with?: Maybe<String>;
  school_ends_with?: Maybe<String>;
  school_not_ends_with?: Maybe<String>;
  about_me?: Maybe<String>;
  about_me_not?: Maybe<String>;
  about_me_in?: Maybe<String[] | String>;
  about_me_not_in?: Maybe<String[] | String>;
  about_me_lt?: Maybe<String>;
  about_me_lte?: Maybe<String>;
  about_me_gt?: Maybe<String>;
  about_me_gte?: Maybe<String>;
  about_me_contains?: Maybe<String>;
  about_me_not_contains?: Maybe<String>;
  about_me_starts_with?: Maybe<String>;
  about_me_not_starts_with?: Maybe<String>;
  about_me_ends_with?: Maybe<String>;
  about_me_not_ends_with?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  receive_push_notifications_not?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  oneSignalPlayerId_not?: Maybe<String>;
  oneSignalPlayerId_in?: Maybe<String[] | String>;
  oneSignalPlayerId_not_in?: Maybe<String[] | String>;
  oneSignalPlayerId_lt?: Maybe<String>;
  oneSignalPlayerId_lte?: Maybe<String>;
  oneSignalPlayerId_gt?: Maybe<String>;
  oneSignalPlayerId_gte?: Maybe<String>;
  oneSignalPlayerId_contains?: Maybe<String>;
  oneSignalPlayerId_not_contains?: Maybe<String>;
  oneSignalPlayerId_starts_with?: Maybe<String>;
  oneSignalPlayerId_not_starts_with?: Maybe<String>;
  oneSignalPlayerId_ends_with?: Maybe<String>;
  oneSignalPlayerId_not_ends_with?: Maybe<String>;
  fcm_token?: Maybe<String>;
  fcm_token_not?: Maybe<String>;
  fcm_token_in?: Maybe<String[] | String>;
  fcm_token_not_in?: Maybe<String[] | String>;
  fcm_token_lt?: Maybe<String>;
  fcm_token_lte?: Maybe<String>;
  fcm_token_gt?: Maybe<String>;
  fcm_token_gte?: Maybe<String>;
  fcm_token_contains?: Maybe<String>;
  fcm_token_not_contains?: Maybe<String>;
  fcm_token_starts_with?: Maybe<String>;
  fcm_token_not_starts_with?: Maybe<String>;
  fcm_token_ends_with?: Maybe<String>;
  fcm_token_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  facebook_social_link?: Maybe<String>;
  facebook_social_link_not?: Maybe<String>;
  facebook_social_link_in?: Maybe<String[] | String>;
  facebook_social_link_not_in?: Maybe<String[] | String>;
  facebook_social_link_lt?: Maybe<String>;
  facebook_social_link_lte?: Maybe<String>;
  facebook_social_link_gt?: Maybe<String>;
  facebook_social_link_gte?: Maybe<String>;
  facebook_social_link_contains?: Maybe<String>;
  facebook_social_link_not_contains?: Maybe<String>;
  facebook_social_link_starts_with?: Maybe<String>;
  facebook_social_link_not_starts_with?: Maybe<String>;
  facebook_social_link_ends_with?: Maybe<String>;
  facebook_social_link_not_ends_with?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  twitter_social_link_not?: Maybe<String>;
  twitter_social_link_in?: Maybe<String[] | String>;
  twitter_social_link_not_in?: Maybe<String[] | String>;
  twitter_social_link_lt?: Maybe<String>;
  twitter_social_link_lte?: Maybe<String>;
  twitter_social_link_gt?: Maybe<String>;
  twitter_social_link_gte?: Maybe<String>;
  twitter_social_link_contains?: Maybe<String>;
  twitter_social_link_not_contains?: Maybe<String>;
  twitter_social_link_starts_with?: Maybe<String>;
  twitter_social_link_not_starts_with?: Maybe<String>;
  twitter_social_link_ends_with?: Maybe<String>;
  twitter_social_link_not_ends_with?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  instagram_social_link_not?: Maybe<String>;
  instagram_social_link_in?: Maybe<String[] | String>;
  instagram_social_link_not_in?: Maybe<String[] | String>;
  instagram_social_link_lt?: Maybe<String>;
  instagram_social_link_lte?: Maybe<String>;
  instagram_social_link_gt?: Maybe<String>;
  instagram_social_link_gte?: Maybe<String>;
  instagram_social_link_contains?: Maybe<String>;
  instagram_social_link_not_contains?: Maybe<String>;
  instagram_social_link_starts_with?: Maybe<String>;
  instagram_social_link_not_starts_with?: Maybe<String>;
  instagram_social_link_ends_with?: Maybe<String>;
  instagram_social_link_not_ends_with?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  snapchat_social_link_not?: Maybe<String>;
  snapchat_social_link_in?: Maybe<String[] | String>;
  snapchat_social_link_not_in?: Maybe<String[] | String>;
  snapchat_social_link_lt?: Maybe<String>;
  snapchat_social_link_lte?: Maybe<String>;
  snapchat_social_link_gt?: Maybe<String>;
  snapchat_social_link_gte?: Maybe<String>;
  snapchat_social_link_contains?: Maybe<String>;
  snapchat_social_link_not_contains?: Maybe<String>;
  snapchat_social_link_starts_with?: Maybe<String>;
  snapchat_social_link_not_starts_with?: Maybe<String>;
  snapchat_social_link_ends_with?: Maybe<String>;
  snapchat_social_link_not_ends_with?: Maybe<String>;
  role?: Maybe<ROLE>;
  role_not?: Maybe<ROLE>;
  role_in?: Maybe<ROLE[] | ROLE>;
  role_not_in?: Maybe<ROLE[] | ROLE>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface NotificationUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image_url?: Maybe<String>;
  data?: Maybe<Json>;
  expiration?: Maybe<DateTimeInput>;
  read?: Maybe<Boolean>;
}

export interface TaskUpsertWithWhereUniqueWithoutCategoryInput {
  where: TaskWhereUniqueInput;
  update: TaskUpdateWithoutCategoryDataInput;
  create: TaskCreateWithoutCategoryInput;
}

export interface UserUpdateWithoutNotificationsDataInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  block_list?: Maybe<UserUpdateManyInput>;
  tasks?: Maybe<TaskUpdateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryUpdateManyWithoutUserInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutParticipantsInput>;
}

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
}

export interface UserUpdateOneRequiredWithoutNotificationsInput {
  create?: Maybe<UserCreateWithoutNotificationsInput>;
  update?: Maybe<UserUpdateWithoutNotificationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutNotificationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TaskUpdateManyWithoutParticipantsInput {
  create?: Maybe<
    TaskCreateWithoutParticipantsInput[] | TaskCreateWithoutParticipantsInput
  >;
  delete?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
  connect?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
  set?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
  disconnect?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
  update?: Maybe<
    | TaskUpdateWithWhereUniqueWithoutParticipantsInput[]
    | TaskUpdateWithWhereUniqueWithoutParticipantsInput
  >;
  upsert?: Maybe<
    | TaskUpsertWithWhereUniqueWithoutParticipantsInput[]
    | TaskUpsertWithWhereUniqueWithoutParticipantsInput
  >;
  deleteMany?: Maybe<TaskScalarWhereInput[] | TaskScalarWhereInput>;
  updateMany?: Maybe<
    TaskUpdateManyWithWhereNestedInput[] | TaskUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateWithoutNotificationsInput {
  id?: Maybe<ID_Input>;
  email: String;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  block_list?: Maybe<UserCreateManyInput>;
  tasks?: Maybe<TaskCreateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewCreateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryCreateManyWithoutUserInput>;
  conversations?: Maybe<ConversationCreateManyWithoutParticipantsInput>;
}

export interface TaskUpdateWithWhereUniqueWithoutParticipantsInput {
  where: TaskWhereUniqueInput;
  data: TaskUpdateWithoutParticipantsDataInput;
}

export interface UserCreateOneWithoutNotificationsInput {
  create?: Maybe<UserCreateWithoutNotificationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TaskUpdateWithoutParticipantsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutTaskInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutTaskInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutTasksInput>;
}

export interface ConversationUpdateManyMutationInput {
  description?: Maybe<String>;
  active?: Maybe<Boolean>;
}

export interface ConversationUpdateManyWithoutTaskInput {
  create?: Maybe<
    ConversationCreateWithoutTaskInput[] | ConversationCreateWithoutTaskInput
  >;
  delete?: Maybe<ConversationWhereUniqueInput[] | ConversationWhereUniqueInput>;
  connect?: Maybe<
    ConversationWhereUniqueInput[] | ConversationWhereUniqueInput
  >;
  set?: Maybe<ConversationWhereUniqueInput[] | ConversationWhereUniqueInput>;
  disconnect?: Maybe<
    ConversationWhereUniqueInput[] | ConversationWhereUniqueInput
  >;
  update?: Maybe<
    | ConversationUpdateWithWhereUniqueWithoutTaskInput[]
    | ConversationUpdateWithWhereUniqueWithoutTaskInput
  >;
  upsert?: Maybe<
    | ConversationUpsertWithWhereUniqueWithoutTaskInput[]
    | ConversationUpsertWithWhereUniqueWithoutTaskInput
  >;
  deleteMany?: Maybe<
    ConversationScalarWhereInput[] | ConversationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ConversationUpdateManyWithWhereNestedInput[]
    | ConversationUpdateManyWithWhereNestedInput
  >;
}

export interface ConversationUpdateInput {
  description?: Maybe<String>;
  active?: Maybe<Boolean>;
  participants?: Maybe<UserUpdateManyWithoutConversationsInput>;
  task?: Maybe<TaskUpdateOneWithoutConversationsInput>;
}

export interface ConversationUpdateWithWhereUniqueWithoutTaskInput {
  where: ConversationWhereUniqueInput;
  data: ConversationUpdateWithoutTaskDataInput;
}

export interface CategoryUpdateManyMutationInput {
  title?: Maybe<String>;
  image_url?: Maybe<String>;
}

export interface ConversationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  participants_every?: Maybe<UserWhereInput>;
  participants_some?: Maybe<UserWhereInput>;
  participants_none?: Maybe<UserWhereInput>;
  task?: Maybe<TaskWhereInput>;
  AND?: Maybe<ConversationWhereInput[] | ConversationWhereInput>;
  OR?: Maybe<ConversationWhereInput[] | ConversationWhereInput>;
  NOT?: Maybe<ConversationWhereInput[] | ConversationWhereInput>;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  image_url?: Maybe<String>;
  tasks?: Maybe<TaskCreateManyWithoutCategoryInput>;
  userCategories?: Maybe<UserCategoryCreateManyWithoutCategoryInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface TaskCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator: UserCreateOneInput;
  participants?: Maybe<UserCreateManyWithoutTasksInput>;
  conversations?: Maybe<ConversationCreateManyWithoutTaskInput>;
  reviews?: Maybe<ReviewCreateManyWithoutTaskInput>;
}

export interface TaskUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  block_list?: Maybe<UserCreateManyInput>;
  tasks?: Maybe<TaskCreateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewCreateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryCreateManyWithoutUserInput>;
  conversations?: Maybe<ConversationCreateManyWithoutParticipantsInput>;
}

export interface UserUpdateWithoutConversationsDataInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  block_list?: Maybe<UserUpdateManyInput>;
  tasks?: Maybe<TaskUpdateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryUpdateManyWithoutUserInput>;
}

export interface NotificationCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  image_url?: Maybe<String>;
  data?: Maybe<Json>;
  expiration: DateTimeInput;
  read?: Maybe<Boolean>;
}

export interface ReviewUpdateManyWithoutReviewerInput {
  create?: Maybe<
    ReviewCreateWithoutReviewerInput[] | ReviewCreateWithoutReviewerInput
  >;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  update?: Maybe<
    | ReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    | ReviewUpdateWithWhereUniqueWithoutReviewerInput
  >;
  upsert?: Maybe<
    | ReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    | ReviewUpsertWithWhereUniqueWithoutReviewerInput
  >;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput
  >;
}

export interface TaskCreateManyWithoutParticipantsInput {
  create?: Maybe<
    TaskCreateWithoutParticipantsInput[] | TaskCreateWithoutParticipantsInput
  >;
  connect?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
}

export interface ReviewUpdateWithWhereUniqueWithoutReviewerInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutReviewerDataInput;
}

export interface ConversationCreateManyWithoutTaskInput {
  create?: Maybe<
    ConversationCreateWithoutTaskInput[] | ConversationCreateWithoutTaskInput
  >;
  connect?: Maybe<
    ConversationWhereUniqueInput[] | ConversationWhereUniqueInput
  >;
}

export interface ReviewUpdateWithoutReviewerDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  rating?: Maybe<RATING>;
  task?: Maybe<TaskUpdateOneWithoutReviewsInput>;
}

export interface UserCreateManyWithoutConversationsInput {
  create?: Maybe<
    UserCreateWithoutConversationsInput[] | UserCreateWithoutConversationsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface TaskUpdateOneWithoutReviewsInput {
  create?: Maybe<TaskCreateWithoutReviewsInput>;
  update?: Maybe<TaskUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<TaskUpsertWithoutReviewsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TaskWhereUniqueInput>;
}

export interface ReviewCreateManyWithoutReviewerInput {
  create?: Maybe<
    ReviewCreateWithoutReviewerInput[] | ReviewCreateWithoutReviewerInput
  >;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export interface TaskUpdateWithoutReviewsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  participants?: Maybe<UserUpdateManyWithoutTasksInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutTaskInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutTasksInput>;
}

export interface TaskCreateOneWithoutReviewsInput {
  create?: Maybe<TaskCreateWithoutReviewsInput>;
  connect?: Maybe<TaskWhereUniqueInput>;
}

export interface UserUpdateManyWithoutTasksInput {
  create?: Maybe<UserCreateWithoutTasksInput[] | UserCreateWithoutTasksInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutTasksInput[]
    | UserUpdateWithWhereUniqueWithoutTasksInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutTasksInput[]
    | UserUpsertWithWhereUniqueWithoutTasksInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateManyWithoutTasksInput {
  create?: Maybe<UserCreateWithoutTasksInput[] | UserCreateWithoutTasksInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserUpdateWithWhereUniqueWithoutTasksInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTasksDataInput;
}

export interface UserCategoryCreateManyWithoutUserInput {
  create?: Maybe<
    UserCategoryCreateWithoutUserInput[] | UserCategoryCreateWithoutUserInput
  >;
  connect?: Maybe<
    UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput
  >;
}

export interface UserUpdateWithoutTasksDataInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  block_list?: Maybe<UserUpdateManyInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryUpdateManyWithoutUserInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutParticipantsInput>;
}

export interface CategoryCreateOneWithoutUserCategoriesInput {
  create?: Maybe<CategoryCreateWithoutUserCategoriesInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface UserCategoryUpdateManyWithoutUserInput {
  create?: Maybe<
    UserCategoryCreateWithoutUserInput[] | UserCategoryCreateWithoutUserInput
  >;
  delete?: Maybe<UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput>;
  connect?: Maybe<
    UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput
  >;
  set?: Maybe<UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput>;
  disconnect?: Maybe<
    UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput
  >;
  update?: Maybe<
    | UserCategoryUpdateWithWhereUniqueWithoutUserInput[]
    | UserCategoryUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserCategoryUpsertWithWhereUniqueWithoutUserInput[]
    | UserCategoryUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    UserCategoryScalarWhereInput[] | UserCategoryScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserCategoryUpdateManyWithWhereNestedInput[]
    | UserCategoryUpdateManyWithWhereNestedInput
  >;
}

export interface ConversationCreateManyWithoutParticipantsInput {
  create?: Maybe<
    | ConversationCreateWithoutParticipantsInput[]
    | ConversationCreateWithoutParticipantsInput
  >;
  connect?: Maybe<
    ConversationWhereUniqueInput[] | ConversationWhereUniqueInput
  >;
}

export interface UserCategoryUpdateWithWhereUniqueWithoutUserInput {
  where: UserCategoryWhereUniqueInput;
  data: UserCategoryUpdateWithoutUserDataInput;
}

export interface TaskCreateOneWithoutConversationsInput {
  create?: Maybe<TaskCreateWithoutConversationsInput>;
  connect?: Maybe<TaskWhereUniqueInput>;
}

export interface UserCategoryUpdateWithoutUserDataInput {
  category?: Maybe<CategoryUpdateOneWithoutUserCategoriesInput>;
  selected?: Maybe<Boolean>;
}

export interface ReviewCreateManyWithoutTaskInput {
  create?: Maybe<ReviewCreateWithoutTaskInput[] | ReviewCreateWithoutTaskInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export interface CategoryUpdateOneWithoutUserCategoriesInput {
  create?: Maybe<CategoryCreateWithoutUserCategoriesInput>;
  update?: Maybe<CategoryUpdateWithoutUserCategoriesDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutUserCategoriesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface UserCreateOneWithoutReviewsInput {
  create?: Maybe<UserCreateWithoutReviewsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CategoryUpdateWithoutUserCategoriesDataInput {
  title?: Maybe<String>;
  image_url?: Maybe<String>;
  tasks?: Maybe<TaskUpdateManyWithoutCategoryInput>;
}

export interface CategoryCreateOneWithoutTasksInput {
  create?: Maybe<CategoryCreateWithoutTasksInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryUpsertWithoutUserCategoriesInput {
  update: CategoryUpdateWithoutUserCategoriesDataInput;
  create: CategoryCreateWithoutUserCategoriesInput;
}

export interface UserCategoryCreateManyWithoutCategoryInput {
  create?: Maybe<
    | UserCategoryCreateWithoutCategoryInput[]
    | UserCategoryCreateWithoutCategoryInput
  >;
  connect?: Maybe<
    UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput
  >;
}

export interface UserCategoryUpsertWithWhereUniqueWithoutUserInput {
  where: UserCategoryWhereUniqueInput;
  update: UserCategoryUpdateWithoutUserDataInput;
  create: UserCategoryCreateWithoutUserInput;
}

export interface UserCreateOneWithoutCategoriesInput {
  create?: Maybe<UserCreateWithoutCategoriesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  selected?: Maybe<Boolean>;
  selected_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserCategoryScalarWhereInput[] | UserCategoryScalarWhereInput>;
  OR?: Maybe<UserCategoryScalarWhereInput[] | UserCategoryScalarWhereInput>;
  NOT?: Maybe<UserCategoryScalarWhereInput[] | UserCategoryScalarWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserCategoryUpdateManyWithWhereNestedInput {
  where: UserCategoryScalarWhereInput;
  data: UserCategoryUpdateManyDataInput;
}

export interface SchoolSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SchoolWhereInput>;
  AND?: Maybe<SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput>;
  OR?: Maybe<SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput>;
  NOT?: Maybe<SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput>;
}

export interface UserCategoryUpdateManyDataInput {
  selected?: Maybe<Boolean>;
}

export interface ConversationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ConversationWhereInput>;
  AND?: Maybe<
    ConversationSubscriptionWhereInput[] | ConversationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ConversationSubscriptionWhereInput[] | ConversationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ConversationSubscriptionWhereInput[] | ConversationSubscriptionWhereInput
  >;
}

export interface ConversationUpdateManyWithoutParticipantsInput {
  create?: Maybe<
    | ConversationCreateWithoutParticipantsInput[]
    | ConversationCreateWithoutParticipantsInput
  >;
  delete?: Maybe<ConversationWhereUniqueInput[] | ConversationWhereUniqueInput>;
  connect?: Maybe<
    ConversationWhereUniqueInput[] | ConversationWhereUniqueInput
  >;
  set?: Maybe<ConversationWhereUniqueInput[] | ConversationWhereUniqueInput>;
  disconnect?: Maybe<
    ConversationWhereUniqueInput[] | ConversationWhereUniqueInput
  >;
  update?: Maybe<
    | ConversationUpdateWithWhereUniqueWithoutParticipantsInput[]
    | ConversationUpdateWithWhereUniqueWithoutParticipantsInput
  >;
  upsert?: Maybe<
    | ConversationUpsertWithWhereUniqueWithoutParticipantsInput[]
    | ConversationUpsertWithWhereUniqueWithoutParticipantsInput
  >;
  deleteMany?: Maybe<
    ConversationScalarWhereInput[] | ConversationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ConversationUpdateManyWithWhereNestedInput[]
    | ConversationUpdateManyWithWhereNestedInput
  >;
}

export interface UserCategoryCreateInput {
  id?: Maybe<ID_Input>;
  category?: Maybe<CategoryCreateOneWithoutUserCategoriesInput>;
  selected?: Maybe<Boolean>;
  user?: Maybe<UserCreateOneWithoutCategoriesInput>;
}

export interface ConversationUpdateWithWhereUniqueWithoutParticipantsInput {
  where: ConversationWhereUniqueInput;
  data: ConversationUpdateWithoutParticipantsDataInput;
}

export interface TaskUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
}

export interface ConversationUpdateWithoutParticipantsDataInput {
  description?: Maybe<String>;
  active?: Maybe<Boolean>;
  task?: Maybe<TaskUpdateOneWithoutConversationsInput>;
}

export interface SchoolUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  domain?: Maybe<String>;
  active?: Maybe<Boolean>;
}

export interface TaskUpdateOneWithoutConversationsInput {
  create?: Maybe<TaskCreateWithoutConversationsInput>;
  update?: Maybe<TaskUpdateWithoutConversationsDataInput>;
  upsert?: Maybe<TaskUpsertWithoutConversationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TaskWhereUniqueInput>;
}

export interface ReviewUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  rating?: Maybe<RATING>;
}

export interface TaskUpdateWithoutConversationsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  participants?: Maybe<UserUpdateManyWithoutTasksInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutTaskInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutTasksInput>;
}

export interface ReviewCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  rating?: Maybe<RATING>;
  reviewer: UserCreateOneWithoutReviewsInput;
  task?: Maybe<TaskCreateOneWithoutReviewsInput>;
}

export interface ReviewUpdateManyWithoutTaskInput {
  create?: Maybe<ReviewCreateWithoutTaskInput[] | ReviewCreateWithoutTaskInput>;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  update?: Maybe<
    | ReviewUpdateWithWhereUniqueWithoutTaskInput[]
    | ReviewUpdateWithWhereUniqueWithoutTaskInput
  >;
  upsert?: Maybe<
    | ReviewUpsertWithWhereUniqueWithoutTaskInput[]
    | ReviewUpsertWithWhereUniqueWithoutTaskInput
  >;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput
  >;
}

export type TaskWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ReviewUpdateWithWhereUniqueWithoutTaskInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutTaskDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ReviewUpdateWithoutTaskDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  rating?: Maybe<RATING>;
  reviewer?: Maybe<UserUpdateOneRequiredWithoutReviewsInput>;
}

export type UserCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutReviewsInput {
  create?: Maybe<UserCreateWithoutReviewsInput>;
  update?: Maybe<UserUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<UserUpsertWithoutReviewsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutReviewsDataInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  block_list?: Maybe<UserUpdateManyInput>;
  tasks?: Maybe<TaskUpdateManyWithoutParticipantsInput>;
  categories?: Maybe<UserCategoryUpdateManyWithoutUserInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutParticipantsInput>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserUpsertWithoutReviewsInput {
  update: UserUpdateWithoutReviewsDataInput;
  create: UserCreateWithoutReviewsInput;
}

export interface ConversationCreateWithoutTaskInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  active?: Maybe<Boolean>;
  participants?: Maybe<UserCreateManyWithoutConversationsInput>;
}

export interface ReviewUpsertWithWhereUniqueWithoutTaskInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutTaskDataInput;
  create: ReviewCreateWithoutTaskInput;
}

export interface ReviewCreateWithoutReviewerInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  rating?: Maybe<RATING>;
  task?: Maybe<TaskCreateOneWithoutReviewsInput>;
}

export interface ReviewScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  rating?: Maybe<RATING>;
  rating_not?: Maybe<RATING>;
  rating_in?: Maybe<RATING[] | RATING>;
  rating_not_in?: Maybe<RATING[] | RATING>;
  AND?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  OR?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  NOT?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
}

export interface UserCreateWithoutTasksInput {
  id?: Maybe<ID_Input>;
  email: String;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  block_list?: Maybe<UserCreateManyInput>;
  reviews?: Maybe<ReviewCreateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryCreateManyWithoutUserInput>;
  conversations?: Maybe<ConversationCreateManyWithoutParticipantsInput>;
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput;
  data: ReviewUpdateManyDataInput;
}

export interface CategoryCreateWithoutUserCategoriesInput {
  id?: Maybe<ID_Input>;
  title: String;
  image_url?: Maybe<String>;
  tasks?: Maybe<TaskCreateManyWithoutCategoryInput>;
}

export interface ReviewUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  rating?: Maybe<RATING>;
}

export interface TaskCreateWithoutConversationsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator: UserCreateOneInput;
  participants?: Maybe<UserCreateManyWithoutTasksInput>;
  reviews?: Maybe<ReviewCreateManyWithoutTaskInput>;
  category: CategoryCreateOneWithoutTasksInput;
}

export interface CategoryUpdateOneRequiredWithoutTasksInput {
  create?: Maybe<CategoryCreateWithoutTasksInput>;
  update?: Maybe<CategoryUpdateWithoutTasksDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutTasksInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface UserCreateWithoutReviewsInput {
  id?: Maybe<ID_Input>;
  email: String;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  block_list?: Maybe<UserCreateManyInput>;
  tasks?: Maybe<TaskCreateManyWithoutParticipantsInput>;
  categories?: Maybe<UserCategoryCreateManyWithoutUserInput>;
  conversations?: Maybe<ConversationCreateManyWithoutParticipantsInput>;
}

export interface CategoryUpdateWithoutTasksDataInput {
  title?: Maybe<String>;
  image_url?: Maybe<String>;
  userCategories?: Maybe<UserCategoryUpdateManyWithoutCategoryInput>;
}

export interface UserCategoryCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  selected?: Maybe<Boolean>;
  user?: Maybe<UserCreateOneWithoutCategoriesInput>;
}

export interface UserCategoryUpdateManyWithoutCategoryInput {
  create?: Maybe<
    | UserCategoryCreateWithoutCategoryInput[]
    | UserCategoryCreateWithoutCategoryInput
  >;
  delete?: Maybe<UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput>;
  connect?: Maybe<
    UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput
  >;
  set?: Maybe<UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput>;
  disconnect?: Maybe<
    UserCategoryWhereUniqueInput[] | UserCategoryWhereUniqueInput
  >;
  update?: Maybe<
    | UserCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    | UserCategoryUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | UserCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    | UserCategoryUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<
    UserCategoryScalarWhereInput[] | UserCategoryScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserCategoryUpdateManyWithWhereNestedInput[]
    | UserCategoryUpdateManyWithWhereNestedInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  major?: Maybe<String>;
  major_not?: Maybe<String>;
  major_in?: Maybe<String[] | String>;
  major_not_in?: Maybe<String[] | String>;
  major_lt?: Maybe<String>;
  major_lte?: Maybe<String>;
  major_gt?: Maybe<String>;
  major_gte?: Maybe<String>;
  major_contains?: Maybe<String>;
  major_not_contains?: Maybe<String>;
  major_starts_with?: Maybe<String>;
  major_not_starts_with?: Maybe<String>;
  major_ends_with?: Maybe<String>;
  major_not_ends_with?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  townYouGrewUpIn_not?: Maybe<String>;
  townYouGrewUpIn_in?: Maybe<String[] | String>;
  townYouGrewUpIn_not_in?: Maybe<String[] | String>;
  townYouGrewUpIn_lt?: Maybe<String>;
  townYouGrewUpIn_lte?: Maybe<String>;
  townYouGrewUpIn_gt?: Maybe<String>;
  townYouGrewUpIn_gte?: Maybe<String>;
  townYouGrewUpIn_contains?: Maybe<String>;
  townYouGrewUpIn_not_contains?: Maybe<String>;
  townYouGrewUpIn_starts_with?: Maybe<String>;
  townYouGrewUpIn_not_starts_with?: Maybe<String>;
  townYouGrewUpIn_ends_with?: Maybe<String>;
  townYouGrewUpIn_not_ends_with?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  favoriteHobby_not?: Maybe<String>;
  favoriteHobby_in?: Maybe<String[] | String>;
  favoriteHobby_not_in?: Maybe<String[] | String>;
  favoriteHobby_lt?: Maybe<String>;
  favoriteHobby_lte?: Maybe<String>;
  favoriteHobby_gt?: Maybe<String>;
  favoriteHobby_gte?: Maybe<String>;
  favoriteHobby_contains?: Maybe<String>;
  favoriteHobby_not_contains?: Maybe<String>;
  favoriteHobby_starts_with?: Maybe<String>;
  favoriteHobby_not_starts_with?: Maybe<String>;
  favoriteHobby_ends_with?: Maybe<String>;
  favoriteHobby_not_ends_with?: Maybe<String>;
  photo_url?: Maybe<String>;
  photo_url_not?: Maybe<String>;
  photo_url_in?: Maybe<String[] | String>;
  photo_url_not_in?: Maybe<String[] | String>;
  photo_url_lt?: Maybe<String>;
  photo_url_lte?: Maybe<String>;
  photo_url_gt?: Maybe<String>;
  photo_url_gte?: Maybe<String>;
  photo_url_contains?: Maybe<String>;
  photo_url_not_contains?: Maybe<String>;
  photo_url_starts_with?: Maybe<String>;
  photo_url_not_starts_with?: Maybe<String>;
  photo_url_ends_with?: Maybe<String>;
  photo_url_not_ends_with?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  cover_photo_url_not?: Maybe<String>;
  cover_photo_url_in?: Maybe<String[] | String>;
  cover_photo_url_not_in?: Maybe<String[] | String>;
  cover_photo_url_lt?: Maybe<String>;
  cover_photo_url_lte?: Maybe<String>;
  cover_photo_url_gt?: Maybe<String>;
  cover_photo_url_gte?: Maybe<String>;
  cover_photo_url_contains?: Maybe<String>;
  cover_photo_url_not_contains?: Maybe<String>;
  cover_photo_url_starts_with?: Maybe<String>;
  cover_photo_url_not_starts_with?: Maybe<String>;
  cover_photo_url_ends_with?: Maybe<String>;
  cover_photo_url_not_ends_with?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  flagged_as_objectionable_not?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  view_objectionable_content_not?: Maybe<Boolean>;
  school?: Maybe<String>;
  school_not?: Maybe<String>;
  school_in?: Maybe<String[] | String>;
  school_not_in?: Maybe<String[] | String>;
  school_lt?: Maybe<String>;
  school_lte?: Maybe<String>;
  school_gt?: Maybe<String>;
  school_gte?: Maybe<String>;
  school_contains?: Maybe<String>;
  school_not_contains?: Maybe<String>;
  school_starts_with?: Maybe<String>;
  school_not_starts_with?: Maybe<String>;
  school_ends_with?: Maybe<String>;
  school_not_ends_with?: Maybe<String>;
  about_me?: Maybe<String>;
  about_me_not?: Maybe<String>;
  about_me_in?: Maybe<String[] | String>;
  about_me_not_in?: Maybe<String[] | String>;
  about_me_lt?: Maybe<String>;
  about_me_lte?: Maybe<String>;
  about_me_gt?: Maybe<String>;
  about_me_gte?: Maybe<String>;
  about_me_contains?: Maybe<String>;
  about_me_not_contains?: Maybe<String>;
  about_me_starts_with?: Maybe<String>;
  about_me_not_starts_with?: Maybe<String>;
  about_me_ends_with?: Maybe<String>;
  about_me_not_ends_with?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  receive_push_notifications_not?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  oneSignalPlayerId_not?: Maybe<String>;
  oneSignalPlayerId_in?: Maybe<String[] | String>;
  oneSignalPlayerId_not_in?: Maybe<String[] | String>;
  oneSignalPlayerId_lt?: Maybe<String>;
  oneSignalPlayerId_lte?: Maybe<String>;
  oneSignalPlayerId_gt?: Maybe<String>;
  oneSignalPlayerId_gte?: Maybe<String>;
  oneSignalPlayerId_contains?: Maybe<String>;
  oneSignalPlayerId_not_contains?: Maybe<String>;
  oneSignalPlayerId_starts_with?: Maybe<String>;
  oneSignalPlayerId_not_starts_with?: Maybe<String>;
  oneSignalPlayerId_ends_with?: Maybe<String>;
  oneSignalPlayerId_not_ends_with?: Maybe<String>;
  fcm_token?: Maybe<String>;
  fcm_token_not?: Maybe<String>;
  fcm_token_in?: Maybe<String[] | String>;
  fcm_token_not_in?: Maybe<String[] | String>;
  fcm_token_lt?: Maybe<String>;
  fcm_token_lte?: Maybe<String>;
  fcm_token_gt?: Maybe<String>;
  fcm_token_gte?: Maybe<String>;
  fcm_token_contains?: Maybe<String>;
  fcm_token_not_contains?: Maybe<String>;
  fcm_token_starts_with?: Maybe<String>;
  fcm_token_not_starts_with?: Maybe<String>;
  fcm_token_ends_with?: Maybe<String>;
  fcm_token_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  facebook_social_link?: Maybe<String>;
  facebook_social_link_not?: Maybe<String>;
  facebook_social_link_in?: Maybe<String[] | String>;
  facebook_social_link_not_in?: Maybe<String[] | String>;
  facebook_social_link_lt?: Maybe<String>;
  facebook_social_link_lte?: Maybe<String>;
  facebook_social_link_gt?: Maybe<String>;
  facebook_social_link_gte?: Maybe<String>;
  facebook_social_link_contains?: Maybe<String>;
  facebook_social_link_not_contains?: Maybe<String>;
  facebook_social_link_starts_with?: Maybe<String>;
  facebook_social_link_not_starts_with?: Maybe<String>;
  facebook_social_link_ends_with?: Maybe<String>;
  facebook_social_link_not_ends_with?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  twitter_social_link_not?: Maybe<String>;
  twitter_social_link_in?: Maybe<String[] | String>;
  twitter_social_link_not_in?: Maybe<String[] | String>;
  twitter_social_link_lt?: Maybe<String>;
  twitter_social_link_lte?: Maybe<String>;
  twitter_social_link_gt?: Maybe<String>;
  twitter_social_link_gte?: Maybe<String>;
  twitter_social_link_contains?: Maybe<String>;
  twitter_social_link_not_contains?: Maybe<String>;
  twitter_social_link_starts_with?: Maybe<String>;
  twitter_social_link_not_starts_with?: Maybe<String>;
  twitter_social_link_ends_with?: Maybe<String>;
  twitter_social_link_not_ends_with?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  instagram_social_link_not?: Maybe<String>;
  instagram_social_link_in?: Maybe<String[] | String>;
  instagram_social_link_not_in?: Maybe<String[] | String>;
  instagram_social_link_lt?: Maybe<String>;
  instagram_social_link_lte?: Maybe<String>;
  instagram_social_link_gt?: Maybe<String>;
  instagram_social_link_gte?: Maybe<String>;
  instagram_social_link_contains?: Maybe<String>;
  instagram_social_link_not_contains?: Maybe<String>;
  instagram_social_link_starts_with?: Maybe<String>;
  instagram_social_link_not_starts_with?: Maybe<String>;
  instagram_social_link_ends_with?: Maybe<String>;
  instagram_social_link_not_ends_with?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  snapchat_social_link_not?: Maybe<String>;
  snapchat_social_link_in?: Maybe<String[] | String>;
  snapchat_social_link_not_in?: Maybe<String[] | String>;
  snapchat_social_link_lt?: Maybe<String>;
  snapchat_social_link_lte?: Maybe<String>;
  snapchat_social_link_gt?: Maybe<String>;
  snapchat_social_link_gte?: Maybe<String>;
  snapchat_social_link_contains?: Maybe<String>;
  snapchat_social_link_not_contains?: Maybe<String>;
  snapchat_social_link_starts_with?: Maybe<String>;
  snapchat_social_link_not_starts_with?: Maybe<String>;
  snapchat_social_link_ends_with?: Maybe<String>;
  snapchat_social_link_not_ends_with?: Maybe<String>;
  role?: Maybe<ROLE>;
  role_not?: Maybe<ROLE>;
  role_in?: Maybe<ROLE[] | ROLE>;
  role_not_in?: Maybe<ROLE[] | ROLE>;
  notifications_every?: Maybe<NotificationWhereInput>;
  notifications_some?: Maybe<NotificationWhereInput>;
  notifications_none?: Maybe<NotificationWhereInput>;
  block_list_every?: Maybe<UserWhereInput>;
  block_list_some?: Maybe<UserWhereInput>;
  block_list_none?: Maybe<UserWhereInput>;
  tasks_every?: Maybe<TaskWhereInput>;
  tasks_some?: Maybe<TaskWhereInput>;
  tasks_none?: Maybe<TaskWhereInput>;
  reviews_every?: Maybe<ReviewWhereInput>;
  reviews_some?: Maybe<ReviewWhereInput>;
  reviews_none?: Maybe<ReviewWhereInput>;
  categories_every?: Maybe<UserCategoryWhereInput>;
  categories_some?: Maybe<UserCategoryWhereInput>;
  categories_none?: Maybe<UserCategoryWhereInput>;
  conversations_every?: Maybe<ConversationWhereInput>;
  conversations_some?: Maybe<ConversationWhereInput>;
  conversations_none?: Maybe<ConversationWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserCategoryUpdateWithWhereUniqueWithoutCategoryInput {
  where: UserCategoryWhereUniqueInput;
  data: UserCategoryUpdateWithoutCategoryDataInput;
}

export interface UserCategoryUpdateManyMutationInput {
  selected?: Maybe<Boolean>;
}

export interface UserCategoryUpdateWithoutCategoryDataInput {
  selected?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneWithoutCategoriesInput>;
}

export interface TaskUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  participants?: Maybe<UserUpdateManyWithoutTasksInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutTaskInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutTaskInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutTasksInput>;
}

export interface UserUpdateOneWithoutCategoriesInput {
  create?: Maybe<UserCreateWithoutCategoriesInput>;
  update?: Maybe<UserUpdateWithoutCategoriesDataInput>;
  upsert?: Maybe<UserUpsertWithoutCategoriesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ReviewUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  rating?: Maybe<RATING>;
  reviewer?: Maybe<UserUpdateOneRequiredWithoutReviewsInput>;
  task?: Maybe<TaskUpdateOneWithoutReviewsInput>;
}

export interface UserUpdateWithoutCategoriesDataInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  block_list?: Maybe<UserUpdateManyInput>;
  tasks?: Maybe<TaskUpdateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutReviewerInput>;
  conversations?: Maybe<ConversationUpdateManyWithoutParticipantsInput>;
}

export interface NotificationUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image_url?: Maybe<String>;
  data?: Maybe<Json>;
  expiration?: Maybe<DateTimeInput>;
  read?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutNotificationsInput>;
}

export interface UserUpsertWithoutCategoriesInput {
  update: UserUpdateWithoutCategoriesDataInput;
  create: UserCreateWithoutCategoriesInput;
}

export interface ConversationCreateInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  active?: Maybe<Boolean>;
  participants?: Maybe<UserCreateManyWithoutConversationsInput>;
  task?: Maybe<TaskCreateOneWithoutConversationsInput>;
}

export interface UserCategoryUpsertWithWhereUniqueWithoutCategoryInput {
  where: UserCategoryWhereUniqueInput;
  update: UserCategoryUpdateWithoutCategoryDataInput;
  create: UserCategoryCreateWithoutCategoryInput;
}

export interface NotificationCreateManyWithoutUserInput {
  create?: Maybe<
    NotificationCreateWithoutUserInput[] | NotificationCreateWithoutUserInput
  >;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
}

export interface CategoryUpsertWithoutTasksInput {
  update: CategoryUpdateWithoutTasksDataInput;
  create: CategoryCreateWithoutTasksInput;
}

export interface UserCreateWithoutConversationsInput {
  id?: Maybe<ID_Input>;
  email: String;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  block_list?: Maybe<UserCreateManyInput>;
  tasks?: Maybe<TaskCreateManyWithoutParticipantsInput>;
  reviews?: Maybe<ReviewCreateManyWithoutReviewerInput>;
  categories?: Maybe<UserCategoryCreateManyWithoutUserInput>;
}

export interface TaskUpsertWithoutConversationsInput {
  update: TaskUpdateWithoutConversationsDataInput;
  create: TaskCreateWithoutConversationsInput;
}

export interface UserCategoryCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  category?: Maybe<CategoryCreateOneWithoutUserCategoriesInput>;
  selected?: Maybe<Boolean>;
}

export interface ConversationUpsertWithWhereUniqueWithoutParticipantsInput {
  where: ConversationWhereUniqueInput;
  update: ConversationUpdateWithoutParticipantsDataInput;
  create: ConversationCreateWithoutParticipantsInput;
}

export interface ReviewCreateWithoutTaskInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  rating?: Maybe<RATING>;
  reviewer: UserCreateOneWithoutReviewsInput;
}

export interface ConversationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ConversationScalarWhereInput[] | ConversationScalarWhereInput>;
  OR?: Maybe<ConversationScalarWhereInput[] | ConversationScalarWhereInput>;
  NOT?: Maybe<ConversationScalarWhereInput[] | ConversationScalarWhereInput>;
}

export interface ReviewWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  rating?: Maybe<RATING>;
  rating_not?: Maybe<RATING>;
  rating_in?: Maybe<RATING[] | RATING>;
  rating_not_in?: Maybe<RATING[] | RATING>;
  reviewer?: Maybe<UserWhereInput>;
  task?: Maybe<TaskWhereInput>;
  AND?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  OR?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  NOT?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
}

export interface ConversationUpdateManyWithWhereNestedInput {
  where: ConversationScalarWhereInput;
  data: ConversationUpdateManyDataInput;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  description?: Maybe<String>;
  major?: Maybe<String>;
  townYouGrewUpIn?: Maybe<String>;
  favoriteHobby?: Maybe<String>;
  photo_url?: Maybe<String>;
  cover_photo_url?: Maybe<String>;
  flagged_as_objectionable?: Maybe<Boolean>;
  view_objectionable_content?: Maybe<Boolean>;
  school?: Maybe<String>;
  about_me?: Maybe<String>;
  receive_push_notifications?: Maybe<Boolean>;
  oneSignalPlayerId?: Maybe<String>;
  fcm_token?: Maybe<String>;
  facebook_social_link?: Maybe<String>;
  twitter_social_link?: Maybe<String>;
  instagram_social_link?: Maybe<String>;
  snapchat_social_link?: Maybe<String>;
  role?: Maybe<ROLE>;
}

export interface ConversationUpdateManyDataInput {
  description?: Maybe<String>;
  active?: Maybe<Boolean>;
}

export interface UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput;
  create: UserCreateWithoutNotificationsInput;
}

export interface UserUpsertWithWhereUniqueWithoutTasksInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTasksDataInput;
  create: UserCreateWithoutTasksInput;
}

export interface TaskCreateManyWithoutCategoryInput {
  create?: Maybe<
    TaskCreateWithoutCategoryInput[] | TaskCreateWithoutCategoryInput
  >;
  connect?: Maybe<TaskWhereUniqueInput[] | TaskWhereUniqueInput>;
}

export interface TaskUpsertWithoutReviewsInput {
  update: TaskUpdateWithoutReviewsDataInput;
  create: TaskCreateWithoutReviewsInput;
}

export interface TaskCreateWithoutReviewsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator: UserCreateOneInput;
  participants?: Maybe<UserCreateManyWithoutTasksInput>;
  conversations?: Maybe<ConversationCreateManyWithoutTaskInput>;
  category: CategoryCreateOneWithoutTasksInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutReviewerInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutReviewerDataInput;
  create: ReviewCreateWithoutReviewerInput;
}

export interface CategoryCreateWithoutTasksInput {
  id?: Maybe<ID_Input>;
  title: String;
  image_url?: Maybe<String>;
  userCategories?: Maybe<UserCategoryCreateManyWithoutCategoryInput>;
}

export interface TaskScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  eventTime_not?: Maybe<DateTimeInput>;
  eventTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  eventTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  eventTime_lt?: Maybe<DateTimeInput>;
  eventTime_lte?: Maybe<DateTimeInput>;
  eventTime_gt?: Maybe<DateTimeInput>;
  eventTime_gte?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  featured_not?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  flagged_as_objectionable_not?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  created_by_joinmi_not?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  task_type_not?: Maybe<TASK_TYPE>;
  task_type_in?: Maybe<TASK_TYPE[] | TASK_TYPE>;
  task_type_not_in?: Maybe<TASK_TYPE[] | TASK_TYPE>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TaskScalarWhereInput[] | TaskScalarWhereInput>;
  OR?: Maybe<TaskScalarWhereInput[] | TaskScalarWhereInput>;
  NOT?: Maybe<TaskScalarWhereInput[] | TaskScalarWhereInput>;
}

export interface TaskUpsertWithWhereUniqueWithoutParticipantsInput {
  where: TaskWhereUniqueInput;
  update: TaskUpdateWithoutParticipantsDataInput;
  create: TaskCreateWithoutParticipantsInput;
}

export interface ConversationUpsertWithWhereUniqueWithoutTaskInput {
  where: ConversationWhereUniqueInput;
  update: ConversationUpdateWithoutTaskDataInput;
  create: ConversationCreateWithoutTaskInput;
}

export interface UserUpsertWithWhereUniqueWithoutConversationsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutConversationsDataInput;
  create: UserCreateWithoutConversationsInput;
}

export interface TaskWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  eventTime_not?: Maybe<DateTimeInput>;
  eventTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  eventTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  eventTime_lt?: Maybe<DateTimeInput>;
  eventTime_lte?: Maybe<DateTimeInput>;
  eventTime_gt?: Maybe<DateTimeInput>;
  eventTime_gte?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  featured_not?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  flagged_as_objectionable_not?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  created_by_joinmi_not?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  task_type_not?: Maybe<TASK_TYPE>;
  task_type_in?: Maybe<TASK_TYPE[] | TASK_TYPE>;
  task_type_not_in?: Maybe<TASK_TYPE[] | TASK_TYPE>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  creator?: Maybe<UserWhereInput>;
  participants_every?: Maybe<UserWhereInput>;
  participants_some?: Maybe<UserWhereInput>;
  participants_none?: Maybe<UserWhereInput>;
  conversations_every?: Maybe<ConversationWhereInput>;
  conversations_some?: Maybe<ConversationWhereInput>;
  conversations_none?: Maybe<ConversationWhereInput>;
  reviews_every?: Maybe<ReviewWhereInput>;
  reviews_some?: Maybe<ReviewWhereInput>;
  reviews_none?: Maybe<ReviewWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  AND?: Maybe<TaskWhereInput[] | TaskWhereInput>;
  OR?: Maybe<TaskWhereInput[] | TaskWhereInput>;
  NOT?: Maybe<TaskWhereInput[] | TaskWhereInput>;
}

export interface ConversationCreateWithoutParticipantsInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  active?: Maybe<Boolean>;
  task?: Maybe<TaskCreateOneWithoutConversationsInput>;
}

export interface TaskCreateWithoutParticipantsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  eventTime?: Maybe<DateTimeInput>;
  featured?: Maybe<Boolean>;
  flagged_as_objectionable?: Maybe<Boolean>;
  created_by_joinmi?: Maybe<Boolean>;
  task_type?: Maybe<TASK_TYPE>;
  active?: Maybe<Boolean>;
  expiration?: Maybe<DateTimeInput>;
  creator: UserCreateOneInput;
  conversations?: Maybe<ConversationCreateManyWithoutTaskInput>;
  reviews?: Maybe<ReviewCreateManyWithoutTaskInput>;
  category: CategoryCreateOneWithoutTasksInput;
}

export interface NotificationCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  image_url?: Maybe<String>;
  data?: Maybe<Json>;
  expiration: DateTimeInput;
  read?: Maybe<Boolean>;
  user: UserCreateOneWithoutNotificationsInput;
}

export interface SchoolUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  domain?: Maybe<String>;
  active?: Maybe<Boolean>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserCategoryPreviousValues {
  id: ID_Output;
  selected?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserCategoryPreviousValuesPromise
  extends Promise<UserCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  selected: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<UserCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  selected: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Task {
  id: ID_Output;
  title?: String;
  description?: String;
  location?: String;
  eventTime?: DateTimeOutput;
  featured?: Boolean;
  flagged_as_objectionable?: Boolean;
  created_by_joinmi?: Boolean;
  task_type?: TASK_TYPE;
  active?: Boolean;
  expiration?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TaskPromise extends Promise<Task>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  eventTime: () => Promise<DateTimeOutput>;
  featured: () => Promise<Boolean>;
  flagged_as_objectionable: () => Promise<Boolean>;
  created_by_joinmi: () => Promise<Boolean>;
  task_type: () => Promise<TASK_TYPE>;
  active: () => Promise<Boolean>;
  expiration: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  creator: <T = UserPromise>() => T;
  participants: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversations: <T = FragmentableArray<Conversation>>(args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategoryPromise>() => T;
}

export interface TaskSubscription
  extends Promise<AsyncIterator<Task>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  eventTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  flagged_as_objectionable: () => Promise<AsyncIterator<Boolean>>;
  created_by_joinmi: () => Promise<AsyncIterator<Boolean>>;
  task_type: () => Promise<AsyncIterator<TASK_TYPE>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  creator: <T = UserSubscription>() => T;
  participants: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversations: <T = Promise<AsyncIterator<ConversationSubscription>>>(args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategorySubscription>() => T;
}

export interface TaskNullablePromise
  extends Promise<Task | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  eventTime: () => Promise<DateTimeOutput>;
  featured: () => Promise<Boolean>;
  flagged_as_objectionable: () => Promise<Boolean>;
  created_by_joinmi: () => Promise<Boolean>;
  task_type: () => Promise<TASK_TYPE>;
  active: () => Promise<Boolean>;
  expiration: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  creator: <T = UserPromise>() => T;
  participants: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversations: <T = FragmentableArray<Conversation>>(args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategoryPromise>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  email: String;
  token?: String;
  name?: String;
  username?: String;
  description?: String;
  major?: String;
  townYouGrewUpIn?: String;
  favoriteHobby?: String;
  photo_url?: String;
  cover_photo_url?: String;
  flagged_as_objectionable?: Boolean;
  view_objectionable_content?: Boolean;
  school?: String;
  about_me?: String;
  receive_push_notifications?: Boolean;
  oneSignalPlayerId?: String;
  fcm_token?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  facebook_social_link?: String;
  twitter_social_link?: String;
  instagram_social_link?: String;
  snapchat_social_link?: String;
  role?: ROLE;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  token: () => Promise<String>;
  name: () => Promise<String>;
  username: () => Promise<String>;
  description: () => Promise<String>;
  major: () => Promise<String>;
  townYouGrewUpIn: () => Promise<String>;
  favoriteHobby: () => Promise<String>;
  photo_url: () => Promise<String>;
  cover_photo_url: () => Promise<String>;
  flagged_as_objectionable: () => Promise<Boolean>;
  view_objectionable_content: () => Promise<Boolean>;
  school: () => Promise<String>;
  about_me: () => Promise<String>;
  receive_push_notifications: () => Promise<Boolean>;
  oneSignalPlayerId: () => Promise<String>;
  fcm_token: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  facebook_social_link: () => Promise<String>;
  twitter_social_link: () => Promise<String>;
  instagram_social_link: () => Promise<String>;
  snapchat_social_link: () => Promise<String>;
  role: () => Promise<ROLE>;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  block_list: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tasks: <T = FragmentableArray<Task>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<UserCategory>>(args?: {
    where?: UserCategoryWhereInput;
    orderBy?: UserCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversations: <T = FragmentableArray<Conversation>>(args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  major: () => Promise<AsyncIterator<String>>;
  townYouGrewUpIn: () => Promise<AsyncIterator<String>>;
  favoriteHobby: () => Promise<AsyncIterator<String>>;
  photo_url: () => Promise<AsyncIterator<String>>;
  cover_photo_url: () => Promise<AsyncIterator<String>>;
  flagged_as_objectionable: () => Promise<AsyncIterator<Boolean>>;
  view_objectionable_content: () => Promise<AsyncIterator<Boolean>>;
  school: () => Promise<AsyncIterator<String>>;
  about_me: () => Promise<AsyncIterator<String>>;
  receive_push_notifications: () => Promise<AsyncIterator<Boolean>>;
  oneSignalPlayerId: () => Promise<AsyncIterator<String>>;
  fcm_token: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  facebook_social_link: () => Promise<AsyncIterator<String>>;
  twitter_social_link: () => Promise<AsyncIterator<String>>;
  instagram_social_link: () => Promise<AsyncIterator<String>>;
  snapchat_social_link: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<ROLE>>;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  block_list: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tasks: <T = Promise<AsyncIterator<TaskSubscription>>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = Promise<AsyncIterator<UserCategorySubscription>>>(args?: {
    where?: UserCategoryWhereInput;
    orderBy?: UserCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversations: <T = Promise<AsyncIterator<ConversationSubscription>>>(args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  token: () => Promise<String>;
  name: () => Promise<String>;
  username: () => Promise<String>;
  description: () => Promise<String>;
  major: () => Promise<String>;
  townYouGrewUpIn: () => Promise<String>;
  favoriteHobby: () => Promise<String>;
  photo_url: () => Promise<String>;
  cover_photo_url: () => Promise<String>;
  flagged_as_objectionable: () => Promise<Boolean>;
  view_objectionable_content: () => Promise<Boolean>;
  school: () => Promise<String>;
  about_me: () => Promise<String>;
  receive_push_notifications: () => Promise<Boolean>;
  oneSignalPlayerId: () => Promise<String>;
  fcm_token: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  facebook_social_link: () => Promise<String>;
  twitter_social_link: () => Promise<String>;
  instagram_social_link: () => Promise<String>;
  snapchat_social_link: () => Promise<String>;
  role: () => Promise<ROLE>;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  block_list: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tasks: <T = FragmentableArray<Task>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<UserCategory>>(args?: {
    where?: UserCategoryWhereInput;
    orderBy?: UserCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversations: <T = FragmentableArray<Conversation>>(args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface UserCategoryEdge {
  node: UserCategory;
  cursor: String;
}

export interface UserCategoryEdgePromise
  extends Promise<UserCategoryEdge>,
    Fragmentable {
  node: <T = UserCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserCategoryEdgeSubscription
  extends Promise<AsyncIterator<UserCategoryEdge>>,
    Fragmentable {
  node: <T = UserCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserCategory {
  count: Int;
}

export interface AggregateUserCategoryPromise
  extends Promise<AggregateUserCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserCategorySubscription
  extends Promise<AsyncIterator<AggregateUserCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TaskPreviousValues {
  id: ID_Output;
  title?: String;
  description?: String;
  location?: String;
  eventTime?: DateTimeOutput;
  featured?: Boolean;
  flagged_as_objectionable?: Boolean;
  created_by_joinmi?: Boolean;
  task_type?: TASK_TYPE;
  active?: Boolean;
  expiration?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TaskPreviousValuesPromise
  extends Promise<TaskPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  eventTime: () => Promise<DateTimeOutput>;
  featured: () => Promise<Boolean>;
  flagged_as_objectionable: () => Promise<Boolean>;
  created_by_joinmi: () => Promise<Boolean>;
  task_type: () => Promise<TASK_TYPE>;
  active: () => Promise<Boolean>;
  expiration: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TaskPreviousValuesSubscription
  extends Promise<AsyncIterator<TaskPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  eventTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  flagged_as_objectionable: () => Promise<AsyncIterator<Boolean>>;
  created_by_joinmi: () => Promise<AsyncIterator<Boolean>>;
  task_type: () => Promise<AsyncIterator<TASK_TYPE>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Notification {
  id: ID_Output;
  title?: String;
  description?: String;
  image_url?: String;
  data?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expiration: DateTimeOutput;
  read?: Boolean;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image_url: () => Promise<String>;
  data: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expiration: () => Promise<DateTimeOutput>;
  read: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image_url: () => Promise<AsyncIterator<String>>;
  data: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
  read: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
}

export interface NotificationNullablePromise
  extends Promise<Notification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image_url: () => Promise<String>;
  data: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expiration: () => Promise<DateTimeOutput>;
  read: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserCategoryConnection {
  pageInfo: PageInfo;
  edges: UserCategoryEdge[];
}

export interface UserCategoryConnectionPromise
  extends Promise<UserCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserCategoryEdge>>() => T;
  aggregate: <T = AggregateUserCategoryPromise>() => T;
}

export interface UserCategoryConnectionSubscription
  extends Promise<AsyncIterator<UserCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserCategorySubscription>() => T;
}

export interface AggregateTask {
  count: Int;
}

export interface AggregateTaskPromise
  extends Promise<AggregateTask>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTaskSubscription
  extends Promise<AsyncIterator<AggregateTask>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TaskConnection {
  pageInfo: PageInfo;
  edges: TaskEdge[];
}

export interface TaskConnectionPromise
  extends Promise<TaskConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TaskEdge>>() => T;
  aggregate: <T = AggregateTaskPromise>() => T;
}

export interface TaskConnectionSubscription
  extends Promise<AsyncIterator<TaskConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TaskEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTaskSubscription>() => T;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface SchoolEdge {
  node: School;
  cursor: String;
}

export interface SchoolEdgePromise extends Promise<SchoolEdge>, Fragmentable {
  node: <T = SchoolPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolEdgeSubscription
  extends Promise<AsyncIterator<SchoolEdge>>,
    Fragmentable {
  node: <T = SchoolSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  title: String;
  image_url?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  image_url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  image_url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Category {
  id: ID_Output;
  title: String;
  image_url?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  image_url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  tasks: <T = FragmentableArray<Task>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userCategories: <T = FragmentableArray<UserCategory>>(args?: {
    where?: UserCategoryWhereInput;
    orderBy?: UserCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  image_url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  tasks: <T = Promise<AsyncIterator<TaskSubscription>>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userCategories: <
    T = Promise<AsyncIterator<UserCategorySubscription>>
  >(args?: {
    where?: UserCategoryWhereInput;
    orderBy?: UserCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  image_url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  tasks: <T = FragmentableArray<Task>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userCategories: <T = FragmentableArray<UserCategory>>(args?: {
    where?: UserCategoryWhereInput;
    orderBy?: UserCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  token?: String;
  name?: String;
  username?: String;
  description?: String;
  major?: String;
  townYouGrewUpIn?: String;
  favoriteHobby?: String;
  photo_url?: String;
  cover_photo_url?: String;
  flagged_as_objectionable?: Boolean;
  view_objectionable_content?: Boolean;
  school?: String;
  about_me?: String;
  receive_push_notifications?: Boolean;
  oneSignalPlayerId?: String;
  fcm_token?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  facebook_social_link?: String;
  twitter_social_link?: String;
  instagram_social_link?: String;
  snapchat_social_link?: String;
  role?: ROLE;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  token: () => Promise<String>;
  name: () => Promise<String>;
  username: () => Promise<String>;
  description: () => Promise<String>;
  major: () => Promise<String>;
  townYouGrewUpIn: () => Promise<String>;
  favoriteHobby: () => Promise<String>;
  photo_url: () => Promise<String>;
  cover_photo_url: () => Promise<String>;
  flagged_as_objectionable: () => Promise<Boolean>;
  view_objectionable_content: () => Promise<Boolean>;
  school: () => Promise<String>;
  about_me: () => Promise<String>;
  receive_push_notifications: () => Promise<Boolean>;
  oneSignalPlayerId: () => Promise<String>;
  fcm_token: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  facebook_social_link: () => Promise<String>;
  twitter_social_link: () => Promise<String>;
  instagram_social_link: () => Promise<String>;
  snapchat_social_link: () => Promise<String>;
  role: () => Promise<ROLE>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  major: () => Promise<AsyncIterator<String>>;
  townYouGrewUpIn: () => Promise<AsyncIterator<String>>;
  favoriteHobby: () => Promise<AsyncIterator<String>>;
  photo_url: () => Promise<AsyncIterator<String>>;
  cover_photo_url: () => Promise<AsyncIterator<String>>;
  flagged_as_objectionable: () => Promise<AsyncIterator<Boolean>>;
  view_objectionable_content: () => Promise<AsyncIterator<Boolean>>;
  school: () => Promise<AsyncIterator<String>>;
  about_me: () => Promise<AsyncIterator<String>>;
  receive_push_notifications: () => Promise<AsyncIterator<Boolean>>;
  oneSignalPlayerId: () => Promise<AsyncIterator<String>>;
  fcm_token: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  facebook_social_link: () => Promise<AsyncIterator<String>>;
  twitter_social_link: () => Promise<AsyncIterator<String>>;
  instagram_social_link: () => Promise<AsyncIterator<String>>;
  snapchat_social_link: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<ROLE>>;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ConversationSubscriptionPayload {
  mutation: MutationType;
  node: Conversation;
  updatedFields: String[];
  previousValues: ConversationPreviousValues;
}

export interface ConversationSubscriptionPayloadPromise
  extends Promise<ConversationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConversationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConversationPreviousValuesPromise>() => T;
}

export interface ConversationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConversationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConversationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConversationPreviousValuesSubscription>() => T;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface ConversationPreviousValues {
  id: ID_Output;
  description?: String;
  active: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ConversationPreviousValuesPromise
  extends Promise<ConversationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ConversationPreviousValuesSubscription
  extends Promise<AsyncIterator<ConversationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Conversation {
  id: ID_Output;
  description?: String;
  active: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ConversationPromise
  extends Promise<Conversation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  participants: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  task: <T = TaskPromise>() => T;
}

export interface ConversationSubscription
  extends Promise<AsyncIterator<Conversation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  participants: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  task: <T = TaskSubscription>() => T;
}

export interface ConversationNullablePromise
  extends Promise<Conversation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  participants: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  task: <T = TaskPromise>() => T;
}

export interface AggregateConversation {
  count: Int;
}

export interface AggregateConversationPromise
  extends Promise<AggregateConversation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConversationSubscription
  extends Promise<AsyncIterator<AggregateConversation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface ConversationConnection {
  pageInfo: PageInfo;
  edges: ConversationEdge[];
}

export interface ConversationConnectionPromise
  extends Promise<ConversationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConversationEdge>>() => T;
  aggregate: <T = AggregateConversationPromise>() => T;
}

export interface ConversationConnectionSubscription
  extends Promise<AsyncIterator<ConversationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConversationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConversationSubscription>() => T;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  title?: String;
  description?: String;
  image_url?: String;
  data?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expiration: DateTimeOutput;
  read?: Boolean;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image_url: () => Promise<String>;
  data: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expiration: () => Promise<DateTimeOutput>;
  read: () => Promise<Boolean>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image_url: () => Promise<AsyncIterator<String>>;
  data: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
  read: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserCategory {
  id: ID_Output;
  selected?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserCategoryPromise
  extends Promise<UserCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = CategoryPromise>() => T;
  selected: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface UserCategorySubscription
  extends Promise<AsyncIterator<UserCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: <T = CategorySubscription>() => T;
  selected: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
}

export interface UserCategoryNullablePromise
  extends Promise<UserCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = CategoryPromise>() => T;
  selected: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface AggregateSchool {
  count: Int;
}

export interface AggregateSchoolPromise
  extends Promise<AggregateSchool>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolSubscription
  extends Promise<AsyncIterator<AggregateSchool>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface School {
  id: ID_Output;
  name: String;
  description?: String;
  domain: String;
  active?: Boolean;
}

export interface SchoolPromise extends Promise<School>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  domain: () => Promise<String>;
  active: () => Promise<Boolean>;
}

export interface SchoolSubscription
  extends Promise<AsyncIterator<School>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  domain: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface SchoolNullablePromise
  extends Promise<School | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  domain: () => Promise<String>;
  active: () => Promise<Boolean>;
}

export interface ReviewPreviousValues {
  id: ID_Output;
  title?: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  rating?: RATING;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  rating: () => Promise<RATING>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  rating: () => Promise<AsyncIterator<RATING>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ConversationEdge {
  node: Conversation;
  cursor: String;
}

export interface ConversationEdgePromise
  extends Promise<ConversationEdge>,
    Fragmentable {
  node: <T = ConversationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConversationEdgeSubscription
  extends Promise<AsyncIterator<ConversationEdge>>,
    Fragmentable {
  node: <T = ConversationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TaskEdge {
  node: Task;
  cursor: String;
}

export interface TaskEdgePromise extends Promise<TaskEdge>, Fragmentable {
  node: <T = TaskPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TaskEdgeSubscription
  extends Promise<AsyncIterator<TaskEdge>>,
    Fragmentable {
  node: <T = TaskSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TaskSubscriptionPayload {
  mutation: MutationType;
  node: Task;
  updatedFields: String[];
  previousValues: TaskPreviousValues;
}

export interface TaskSubscriptionPayloadPromise
  extends Promise<TaskSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TaskPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TaskPreviousValuesPromise>() => T;
}

export interface TaskSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TaskSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TaskSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TaskPreviousValuesSubscription>() => T;
}

export interface Review {
  id: ID_Output;
  title?: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  rating?: RATING;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  rating: () => Promise<RATING>;
  reviewer: <T = UserPromise>() => T;
  task: <T = TaskPromise>() => T;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  rating: () => Promise<AsyncIterator<RATING>>;
  reviewer: <T = UserSubscription>() => T;
  task: <T = TaskSubscription>() => T;
}

export interface ReviewNullablePromise
  extends Promise<Review | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  rating: () => Promise<RATING>;
  reviewer: <T = UserPromise>() => T;
  task: <T = TaskPromise>() => T;
}

export interface SchoolPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  domain: String;
  active?: Boolean;
}

export interface SchoolPreviousValuesPromise
  extends Promise<SchoolPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  domain: () => Promise<String>;
  active: () => Promise<Boolean>;
}

export interface SchoolPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  domain: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface SchoolSubscriptionPayload {
  mutation: MutationType;
  node: School;
  updatedFields: String[];
  previousValues: SchoolPreviousValues;
}

export interface SchoolSubscriptionPayloadPromise
  extends Promise<SchoolSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolPreviousValuesPromise>() => T;
}

export interface SchoolSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolPreviousValuesSubscription>() => T;
}

export interface SchoolConnection {
  pageInfo: PageInfo;
  edges: SchoolEdge[];
}

export interface SchoolConnectionPromise
  extends Promise<SchoolConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolEdge>>() => T;
  aggregate: <T = AggregateSchoolPromise>() => T;
}

export interface SchoolConnectionSubscription
  extends Promise<AsyncIterator<SchoolConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolSubscription>() => T;
}

export interface UserCategorySubscriptionPayload {
  mutation: MutationType;
  node: UserCategory;
  updatedFields: String[];
  previousValues: UserCategoryPreviousValues;
}

export interface UserCategorySubscriptionPayloadPromise
  extends Promise<UserCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserCategoryPreviousValuesPromise>() => T;
}

export interface UserCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserCategoryPreviousValuesSubscription>() => T;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Task",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "UserCategory",
    embedded: false
  },
  {
    name: "Conversation",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  },
  {
    name: "School",
    embedded: false
  },
  {
    name: "RATING",
    embedded: false
  },
  {
    name: "TASK_TYPE",
    embedded: false
  },
  {
    name: "ROLE",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://joinm-publi-1jwp04uayr5nf-2099927068.us-east-1.elb.amazonaws.com/JoinMi-BE/stage`
});
export const prisma = new Prisma();
